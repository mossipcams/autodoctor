{
  "config": {
    "step": {
      "user": {
        "title": "Autodoctor",
        "description": "Set up automation validation to detect state-related issues before they cause failures."
      }
    },
    "abort": {
      "single_instance_allowed": "Only a single instance of Autodoctor is allowed."
    }
  },
  "options": {
    "error": {
      "warmup_exceeds_baseline": "Runtime warmup samples cannot exceed runtime baseline days.",
      "baseline_too_short_for_training": "Runtime baseline days must be larger than the internal cold-start window to produce anomaly training rows."
    },
    "step": {
      "init": {
        "title": "Autodoctor Options",
        "data": {
          "history_days": "History lookback period (days)",
          "staleness_threshold_days": "Staleness warning threshold (days)",
          "validate_on_reload": "Automatically validate when automations are reloaded",
          "debounce_seconds": "Debounce delay before validation (seconds)",
          "periodic_scan_interval_hours": "Periodic scan interval (hours)",
          "runtime_health_enabled": "Enable runtime health monitoring (ML)",
          "runtime_health_baseline_days": "Runtime baseline history (days)",
          "runtime_health_warmup_samples": "Runtime warmup samples",
          "runtime_health_anomaly_threshold": "Runtime anomaly threshold",
          "runtime_health_min_expected_events": "Runtime minimum expected events/day",
          "runtime_health_hour_ratio_days": "Runtime hour-ratio lookback (days)",
          "runtime_health_sensitivity": "Runtime sensitivity",
          "runtime_health_burst_multiplier": "Runtime burst multiplier",
          "runtime_health_max_alerts_per_day": "Runtime max alerts/day",
          "runtime_health_smoothing_window": "Runtime smoothing window",
          "runtime_health_restart_exclusion_minutes": "Runtime restart exclusion (minutes)",
          "runtime_health_auto_adapt": "Runtime auto-adapt baselines"
        },
        "data_description": {
          "history_days": "Number of days of state history to analyze",
          "staleness_threshold_days": "Warn if a referenced state hasn't occurred in this many days",
          "validate_on_reload": "Run validation automatically whenever automations are reloaded",
          "debounce_seconds": "Wait this many seconds after reload before validating (prevents multiple rapid validations)",
          "periodic_scan_interval_hours": "Run a background validation scan every N hours and publish issues to Repairs",
          "runtime_health_enabled": "Track automation trigger behavior over time and detect runtime anomalies",
          "runtime_health_baseline_days": "Days of recorder history used to build runtime behavior baseline",
          "runtime_health_warmup_samples": "Minimum active baseline days needed before ML anomaly detection starts",
          "runtime_health_anomaly_threshold": "Score threshold above which runtime behavior is flagged as anomalous",
          "runtime_health_min_expected_events": "Minimum expected daily trigger count needed to evaluate stalling",
          "runtime_health_hour_ratio_days": "Days used to compute current-hour activity ratio against historical same-hour behavior",
          "runtime_health_sensitivity": "Sensitivity profile for count anomaly confidence intervals (low, medium, high)",
          "runtime_health_burst_multiplier": "Multiplier over learned 5-minute baseline rate required to classify a burst",
          "runtime_health_max_alerts_per_day": "Maximum runtime alerts emitted per automation per day",
          "runtime_health_smoothing_window": "Number of consecutive anomalies before auto-adapt can reset the baseline",
          "runtime_health_restart_exclusion_minutes": "Minutes to suppress runtime scoring after startup/restart",
          "runtime_health_auto_adapt": "Automatically reset count baselines after persistent anomalies"
        }
      }
    }
  },
  "issues": {
    "validation_issue": {
      "title": "Automation Issue: {automation}",
      "description": "**Entity:** `{entity}`\n\n**Problem:** {message}\n\n**Suggested fix:** {suggestion}\n\n**Valid states:** {valid_states}"
    },
    "automation_issues": {
      "title": "{automation} ({count} issues)",
      "description": "The following issues were found:\n\n{issues}"
    }
  },
  "entity": {
    "sensor": {
      "autodoctor_issues": {
        "name": "Autodoctor Issues"
      }
    },
    "binary_sensor": {
      "autodoctor_ok": {
        "name": "Autodoctor OK"
      }
    }
  },
  "services": {
    "validate": {
      "name": "Validate Automations",
      "description": "Run validation on all automations or a specific one.",
      "fields": {
        "automation_id": {
          "name": "Automation ID",
          "description": "Optional: specific automation to validate. Leave empty to validate all."
        }
      }
    },
    "simulate": {
      "name": "Verify Outcomes",
      "description": "Verify that automation actions are reachable.",
      "fields": {
        "automation_id": {
          "name": "Automation ID",
          "description": "Optional: specific automation to verify. Leave empty to verify all."
        }
      }
    },
    "refresh_knowledge_base": {
      "name": "Refresh Knowledge Base",
      "description": "Rebuild the state knowledge base from recorder history and entity schemas."
    }
  }
}
