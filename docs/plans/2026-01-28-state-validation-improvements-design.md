# State Validation Improvements Design

## Problem Statement

The current state validation system works well for the developer's Home Assistant instance but has limitations for other users:

1. **False positives for new users** - Valid states flagged as invalid because they're not in the knowledge base yet
2. **Incomplete hardcoded defaults** - Missing states for domains/integrations not encountered
3. **Custom/third-party integrations** - Integrations with non-standard states aren't covered
4. **Limited generalizability** - System needs to work for any HA installation, not just one

## Solution Overview

A two-part approach:

1. **Build-time extraction** - Parse Home Assistant's source code to generate comprehensive state mappings
2. **Runtime learning** - Learn valid states when users dismiss false positives, stored per integration

## Design

### Part 1: Build-Time State Extraction

#### Script: `scripts/extract_ha_states.py`

Parses Home Assistant core to extract valid states from typed enums.

**Inputs:**
- Path to cloned `home-assistant/core` repository
- (Optional) Path to cloned `home-assistant/home-assistant.io` for docs fallback

**Extraction strategy:**

1. Scan `homeassistant/components/*/const.py` for state enums
2. For domains without enums, parse `source/_integrations/*.markdown` for "States" sections
3. Merge with manual overrides for edge cases

**Enum pattern (validated against HA source):**

```python
# Pattern matches:
# class VacuumActivity(StrEnum):
#     CLEANING = "cleaning"
#     DOCKED = "docked"

ENUM_PATTERN = r'class\s+(\w+)\((?:str,\s*)?(?:Str)?Enum\):'
VALUE_PATTERN = r'^\s+(\w+)\s*=\s*["\']([^"\']+)["\']'
```

**Domain-to-enum mappings:**

| Domain | Enum Class | File |
|--------|------------|------|
| vacuum | `VacuumActivity` | `components/vacuum/const.py` |
| alarm_control_panel | `AlarmControlPanelState` | `components/alarm_control_panel/const.py` |
| climate | `HVACMode` | `components/climate/const.py` |
| lock | `LockState` | `components/lock/const.py` |
| cover | `CoverState` | `components/cover/const.py` |
| media_player | `MediaPlayerState` | `components/media_player/const.py` |

**Output:** Regenerated `device_class_states.py`

```python
# AUTO-GENERATED by scripts/extract_ha_states.py
# Source: home-assistant/core @ <commit-hash>
# Generated: <timestamp>
# Do not edit manually - run script to regenerate

DEVICE_CLASS_STATES: dict[str, set[str]] = {
    "vacuum": {"cleaning", "docked", "error", "idle", "paused", "returning"},
    "alarm_control_panel": {
        "disarmed", "armed_home", "armed_away", "armed_night",
        "armed_vacation", "armed_custom_bypass", "pending",
        "arming", "disarming", "triggered"
    },
    "climate": {"off", "heat", "cool", "heat_cool", "auto", "dry", "fan_only"},
    # ... etc
}
```

**Usage:**

```bash
# Clone HA core locally, then:
python scripts/extract_ha_states.py --ha-path ~/home-assistant/core

# With docs fallback:
python scripts/extract_ha_states.py \
    --ha-path ~/home-assistant/core \
    --docs-path ~/home-assistant/home-assistant.io
```

**Maintenance:** Run when new HA versions release to pick up new domains/states.

---

### Part 2: Learning from Dismissals

#### Storage: `learned_states.json`

Located in the integration's config directory (alongside suppressions).

**Data structure:**

```json
{
  "vacuum": {
    "roborock": ["segment_cleaning", "charging_error"],
    "ecovacs": ["auto_clean", "spot_area"]
  },
  "lock": {
    "august": ["unlocking_jammed"]
  }
}
```

**Key:** `{domain}.{integration}` maps to list of learned states.

#### Learning Flow

1. User sees validation issue: `"vacuum.roborock_s7 has invalid state 'segment_cleaning'"`
2. User dismisses/suppresses the issue via UI
3. System detects this is a state validation issue (`IssueType.INVALID_STATE`)
4. Looks up integration from entity registry:
   ```python
   from homeassistant.helpers import entity_registry as er

   entity_registry = er.async_get(hass)
   entry = entity_registry.async_get(entity_id)
   integration = entry.platform if entry else None  # e.g., "roborock"
   ```
5. Adds state to learned states: `learned_states["vacuum"]["roborock"].append("segment_cleaning")`
6. Persists to `learned_states.json`
7. Future validations check learned states before flagging

---

### Part 3: Updated Knowledge Base

#### New Priority Order for `get_valid_states()`

1. **Extracted device class defaults** (from enhanced `device_class_states.py`)
2. **Learned states** (from `learned_states.json` for this integration+domain)
3. **Schema introspection** (entity attributes like `hvac_modes`, `options`)
4. **Recorder history** (observed states)
5. **Current state** (always valid)
6. **Universal states** (`unavailable`, `unknown`)

#### Changes to `StateKnowledgeBase`

```python
class StateKnowledgeBase:
    """Builds and maintains valid states for entities."""

    def __init__(self, hass: HomeAssistant, history_days: int = 30) -> None:
        self.hass = hass
        self.history_days = history_days
        self._cache: dict[str, set[str]] = {}
        self._observed_states: dict[str, set[str]] = {}
        self._learned_states: dict[str, dict[str, list[str]]] = {}  # NEW
        self._lock = asyncio.Lock()

    async def async_load(self) -> None:
        """Load learned states from storage."""
        store = Store(self.hass, 1, "autodoctor.learned_states")
        data = await store.async_load()
        if data:
            self._learned_states = data

    async def async_save_learned(self) -> None:
        """Persist learned states to storage."""
        store = Store(self.hass, 1, "autodoctor.learned_states")
        await store.async_save(self._learned_states)

    def _get_integration(self, entity_id: str) -> str | None:
        """Get the integration/platform that owns this entity."""
        entity_registry = er.async_get(self.hass)
        entry = entity_registry.async_get(entity_id)
        return entry.platform if entry else None

    def get_learned_states(self, entity_id: str) -> set[str]:
        """Get learned states for entity's domain+integration."""
        domain = self.get_domain(entity_id)
        integration = self._get_integration(entity_id)
        if integration and domain in self._learned_states:
            return set(self._learned_states[domain].get(integration, []))
        return set()

    async def async_learn_state(self, entity_id: str, state: str) -> None:
        """Learn a state as valid for this entity's integration."""
        domain = self.get_domain(entity_id)
        integration = self._get_integration(entity_id)

        if not integration:
            return

        if domain not in self._learned_states:
            self._learned_states[domain] = {}

        if integration not in self._learned_states[domain]:
            self._learned_states[domain][integration] = []

        if state not in self._learned_states[domain][integration]:
            self._learned_states[domain][integration].append(state)
            await self.async_save_learned()

            # Invalidate cache for this entity
            self._cache.pop(entity_id, None)
```

#### Updated `get_valid_states()` method

```python
def get_valid_states(self, entity_id: str) -> set[str] | None:
    """Get valid states for an entity."""
    # Check cache first
    if entity_id in self._cache:
        return self._cache[entity_id].copy()

    state = self.hass.states.get(entity_id)
    if state is None:
        return None

    domain = self.get_domain(entity_id)

    # Skip sensors (too free-form)
    if domain == "sensor":
        return None

    # 1. Start with device class defaults
    valid_states = get_device_class_states(domain) or set()
    valid_states = valid_states.copy()

    # 2. Add learned states for this integration+domain (NEW)
    valid_states.update(self.get_learned_states(entity_id))

    # 3. Schema introspection
    if domain in SCHEMA_ATTRIBUTES:
        for attr_name in SCHEMA_ATTRIBUTES[domain]:
            attr_value = state.attributes.get(attr_name)
            if attr_value and isinstance(attr_value, list):
                valid_states.update(str(v) for v in attr_value)

    # 4. Observed states from history
    observed = self._observed_states.get(entity_id)
    if observed:
        valid_states.update(observed)

    # 5. Current state
    if state.state not in ("unavailable", "unknown"):
        valid_states.add(state.state)

    # 6. Universal states
    valid_states.add("unavailable")
    valid_states.add("unknown")

    self._cache[entity_id] = valid_states
    return valid_states.copy()
```

---

### Part 4: Suppression Integration

#### Modified WebSocket Handler

When a user suppresses an issue, check if it's a state validation issue and trigger learning.

```python
@websocket_api.websocket_command({
    vol.Required("type"): "autodoctor/suppress",
    vol.Required("issue_key"): str,
    vol.Optional("entity_id"): str,
    vol.Optional("state"): str,
    vol.Optional("issue_type"): str,
})
async def websocket_suppress(
    hass: HomeAssistant,
    connection: websocket_api.ActiveConnection,
    msg: dict,
) -> None:
    """Suppress a validation issue."""
    issue_key = msg["issue_key"]
    issue_type = msg.get("issue_type")
    entity_id = msg.get("entity_id")
    state = msg.get("state")

    # Learn from dismissal if this is a state validation issue
    if issue_type == "invalid_state" and entity_id and state:
        knowledge_base: StateKnowledgeBase = hass.data[DOMAIN]["knowledge_base"]
        await knowledge_base.async_learn_state(entity_id, state)

    # Suppress the issue
    suppression_store: SuppressionStore = hass.data[DOMAIN]["suppression_store"]
    await suppression_store.async_suppress(issue_key)

    connection.send_result(msg["id"], {"success": True})
```

#### Frontend Changes

The suppress button needs to pass additional context:
- `entity_id` - The entity with the invalid state
- `state` - The state that was flagged as invalid
- `issue_type` - The type of issue being suppressed

---

## File Changes Summary

| File | Change |
|------|--------|
| `scripts/extract_ha_states.py` | NEW - Extraction script |
| `device_class_states.py` | MODIFIED - Regenerated with comprehensive states |
| `knowledge_base.py` | MODIFIED - Add learning methods and priority |
| `websocket_api.py` | MODIFIED - Pass issue details to suppression |
| `learned_states.json` | NEW (runtime) - Persisted learned states |

---

## Testing Strategy

1. **Extraction script tests:**
   - Parse mock const.py files
   - Parse mock markdown docs
   - Verify output format

2. **Learning tests:**
   - Suppress issue → state is learned
   - Learned state persists across restarts
   - Learned state prevents future false positives

3. **Integration tests:**
   - New user with no history → uses extracted defaults
   - User dismisses false positive → learns the state
   - Future validation passes for that integration

---

## Migration

No migration needed. The system is additive:
- Existing `device_class_states.py` continues to work
- `learned_states.json` is created on first dismissal
- No breaking changes to existing suppressions
