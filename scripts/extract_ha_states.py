#!/usr/bin/env python3
"""Extract valid entity states from Home Assistant source code.

This script parses HA core to extract state enums and generates
an updated device_class_states.py file.

Usage:
    python scripts/extract_ha_states.py --ha-path ~/home-assistant/core

Requirements:
    - Clone of home-assistant/core repository
"""

from __future__ import annotations

import argparse
import re
import sys
from datetime import datetime
from pathlib import Path

# Known domain-to-enum mappings
DOMAIN_ENUM_MAPPINGS: dict[str, list[str]] = {
    "vacuum": ["VacuumActivity"],
    "alarm_control_panel": ["AlarmControlPanelState"],
    "climate": ["HVACMode"],
    "lock": ["LockState"],
    "cover": ["CoverState"],
    "media_player": ["MediaPlayerState"],
    "water_heater": ["WaterHeaterOperation"],
    "lawn_mower": ["LawnMowerActivity"],
    "humidifier": ["HumidifierAction"],
}

# Regex patterns
ENUM_CLASS_PATTERN = re.compile(
    r"class\s+(\w+)\s*\(\s*(?:str\s*,\s*)?(?:Str)?Enum\s*\)\s*:", re.MULTILINE
)
ENUM_VALUE_PATTERN = re.compile(r'^\s+(\w+)\s*=\s*["\']([^"\']+)["\']', re.MULTILINE)


def find_const_file(ha_path: Path, domain: str) -> Path | None:
    """Find const.py for a domain."""
    const_path = ha_path / "homeassistant" / "components" / domain / "const.py"
    if const_path.exists():
        return const_path
    return None


def extract_enum_values(content: str, enum_name: str) -> set[str]:
    """Extract values from an enum class definition."""
    values = set()

    pattern = rf"class\s+{enum_name}\s*\([^)]+\)\s*:"
    match = re.search(pattern, content)
    if not match:
        return values

    start = match.end()
    lines = content[start:].split("\n")

    for line in lines:
        if re.match(r"^class\s+|^def\s+|^async\s+def\s+", line):
            break

        value_match = ENUM_VALUE_PATTERN.match(line)
        if value_match:
            values.add(value_match.group(2))

    return values


def extract_domain_states(ha_path: Path, domain: str) -> set[str] | None:
    """Extract valid states for a domain from HA source."""
    const_path = find_const_file(ha_path, domain)
    if not const_path:
        return None

    content = const_path.read_text()

    enum_names = DOMAIN_ENUM_MAPPINGS.get(domain, [])
    for enum_name in enum_names:
        values = extract_enum_values(content, enum_name)
        if values:
            return values

    for match in ENUM_CLASS_PATTERN.finditer(content):
        enum_name = match.group(1)
        if any(x in enum_name for x in ["State", "Activity", "Mode", "Operation"]):
            values = extract_enum_values(content, enum_name)
            if values:
                return values

    return None


def get_git_info(ha_path: Path) -> str:
    """Get git commit info from HA repo."""
    import subprocess

    try:
        result = subprocess.run(
            ["git", "rev-parse", "--short", "HEAD"],
            cwd=ha_path,
            capture_output=True,
            text=True,
        )
        return result.stdout.strip() if result.returncode == 0 else "unknown"
    except Exception:
        return "unknown"


def generate_output(states_by_domain: dict[str, set[str]], ha_commit: str) -> str:
    """Generate the device_class_states.py content."""
    lines = [
        '"""Device class state mappings for known Home Assistant domains.',
        "",
        "Auto-generated by scripts/extract_ha_states.py",
        f"Source: home-assistant/core @ {ha_commit}",
        f"Generated: {datetime.now().isoformat()}",
        "",
        "Do not edit the EXTRACTED_STATES section manually.",
        "Manual additions should go in MANUAL_STATES below.",
        '"""',
        "",
        "from __future__ import annotations",
        "",
        "# States extracted from Home Assistant source",
        "EXTRACTED_STATES: dict[str, set[str]] = {",
    ]

    for domain in sorted(states_by_domain.keys()):
        states = states_by_domain[domain]
        states_str = ", ".join(f'"{s}"' for s in sorted(states))
        lines.append(f'    "{domain}": {{{states_str}}},')

    lines.extend(
        [
            "}",
            "",
            "# Manual additions for domains not extracted from source",
            "# Edit this section to add domain states not in HA core",
            "MANUAL_STATES: dict[str, set[str]] = {",
            '    "binary_sensor": {"on", "off"},',
            '    "switch": {"on", "off"},',
            '    "light": {"on", "off"},',
            '    "fan": {"on", "off"},',
            '    "input_boolean": {"on", "off"},',
            '    "script": {"on", "off"},',
            '    "automation": {"on", "off"},',
            '    "update": {"on", "off"},',
            '    "schedule": {"on", "off"},',
            '    "humidifier": {"on", "off"},',
            '    "siren": {"on", "off"},',
            '    "remote": {"on", "off"},',
            '    "calendar": {"on", "off"},',
            '    "button": {"unknown"},',
            '    "event": {"unknown"},',
            '    "input_button": {"unknown"},',
            '    "scene": {"unknown"},',
            '    "person": {"home", "not_home"},',
            '    "device_tracker": {"home", "not_home"},',
            '    "timer": {"idle", "active", "paused"},',
            "}",
            "",
            "# Combined states (extracted + manual)",
            "DEVICE_CLASS_STATES: dict[str, set[str]] = {",
            "    **EXTRACTED_STATES,",
            "    **MANUAL_STATES,",
            "}",
            "",
            "",
            "def get_device_class_states(domain: str) -> set[str] | None:",
            '    """Get known valid states for a domain.',
            "",
            "    Args:",
            "        domain: The entity domain (e.g., 'binary_sensor', 'lock')",
            "",
            "    Returns:",
            "        Set of valid states, or None if domain is unknown",
            '    """',
            "    return DEVICE_CLASS_STATES.get(domain)",
            "",
            "",
            "def get_all_known_domains() -> set[str]:",
            '    """Get all domains with known state mappings.',
            "",
            "    Returns:",
            "        Set of domain names",
            '    """',
            "    return set(DEVICE_CLASS_STATES.keys())",
            "",
        ]
    )

    return "\n".join(lines)


def main():
    parser = argparse.ArgumentParser(
        description="Extract valid states from Home Assistant source"
    )
    parser.add_argument(
        "--ha-path",
        type=Path,
        required=True,
        help="Path to home-assistant/core repository",
    )
    parser.add_argument(
        "--output",
        type=Path,
        default=None,
        help="Output file path (default: custom_components/autodoctor/device_class_states.py)",
    )
    parser.add_argument(
        "--dry-run", action="store_true", help="Print output instead of writing to file"
    )

    args = parser.parse_args()

    if not args.ha_path.exists():
        print(f"Error: HA path does not exist: {args.ha_path}", file=sys.stderr)
        sys.exit(1)

    states_by_domain: dict[str, set[str]] = {}

    for domain in DOMAIN_ENUM_MAPPINGS:
        states = extract_domain_states(args.ha_path, domain)
        if states:
            states_by_domain[domain] = states
            print(f"Extracted {len(states)} states for {domain}")
        else:
            print(f"Warning: Could not extract states for {domain}")

    ha_commit = get_git_info(args.ha_path)
    output = generate_output(states_by_domain, ha_commit)

    if args.dry_run:
        print(output)
    else:
        output_path = args.output or Path(
            "custom_components/autodoctor/device_class_states.py"
        )
        output_path.write_text(output)
        print(f"Wrote {output_path}")


if __name__ == "__main__":
    main()
